---
layout: default
title: 2.5 ÂçäÂä†ÁÆóÂô®„Å®ÂÖ®Âä†ÁÆóÂô®„ÅÆÊßãÊàê
---

---

# 2.5 ÂçäÂä†ÁÆóÂô®„Å®ÂÖ®Âä†ÁÆóÂô®„ÅÆÊßãÊàê  
**2.5 Structure of Half and Full Adders**

---

## üéØ Êú¨ÁØÄ„ÅÆ„Å≠„Çâ„ÅÑÔΩúGoal of This Section

Êú¨ÁØÄ„Åß„ÅØ„ÄÅ„Éá„Ç∏„Çø„É´ÂõûË∑Ø„ÅßÊúÄ„ÇÇÂü∫Êú¨ÁöÑ„Åã„Å§ÈáçË¶Å„Å™ÊºîÁÆóÂá¶ÁêÜ„Åß„ÅÇ„Çã  
**Âä†ÁÆóÂô®ÔºàAdderÔºâ** „ÅÆÊßãÊàê„ÇíÂ≠¶„Å≥„Åæ„Åô„ÄÇ  
> This section focuses on the fundamental logic blocks‚Äî**Half Adder** and **Full Adder**‚Äîused in digital addition.

---

## üîπ ÂçäÂä†ÁÆóÂô®ÔºàHalf AdderÔºâ  
### üáØüáµ 2ÂÖ•Âäõ„Éì„ÉÉ„Éà„ÅÆÂä†ÁÆó„ÇíË°å„ÅÜÊúÄÂ∞èÊßãÊàêÂõûË∑Ø  
### üá∫üá∏ A minimal logic block that adds two single-bit inputs

- **ÂÖ•Âäõ / Inputs**ÔºöA, BÔºà1„Éì„ÉÉ„ÉàÔºâ  
- **Âá∫Âäõ / Outputs**Ôºö
  - **SumÔºàSÔºâ** = A ‚äï B  
  - **CarryÔºàCÔºâ** = A„ÉªB

### üìã ÁúüÁêÜÂÄ§Ë°®ÔΩúTruth Table

| A | B | S = A ‚äï B | C = A„ÉªB |
|---|---|-----------|----------|
| 0 | 0 |     0     |    0     |
| 0 | 1 |     1     |    0     |
| 1 | 0 |     1     |    0     |
| 1 | 1 |     0     |    1     |

### üìò Âõ≥2.5-1ÔºöÂçäÂä†ÁÆóÂô®„ÅÆÊßãÊàêÂõ≥ÔºàMermaidÔºâ

```mermaid
flowchart LR
    A(A) --> XOR1[XOR]
    B(B) --> XOR1
    XOR1 --> S("S = A ‚äï B")

    A --> AND1[AND]
    B --> AND1
    AND1 --> C("C = A ¬∑ B")
```

> XOR generates the sum, AND generates the carry output.

---

## üîπ ÂÖ®Âä†ÁÆóÂô®ÔºàFull AdderÔºâ  
### üáØüáµ „Ç≠„É£„É™„ÉºÂÖ•Âäõ‰ªò„Åç1„Éì„ÉÉ„ÉàÂä†ÁÆóÂô®  
### üá∫üá∏ A 1-bit adder with carry-in support

- **ÂÖ•Âäõ / Inputs**ÔºöA, B, C\_inÔºà„Ç≠„É£„É™„ÉºÂÖ•ÂäõÔºâ  
- **Âá∫Âäõ / Outputs**Ôºö
  - **SumÔºàSÔºâ** = A ‚äï B ‚äï C\_in  
  - **CarryÔºàC\_outÔºâ** = A„ÉªB + B„ÉªC\_in + A„ÉªC\_in

### üìã ÁúüÁêÜÂÄ§Ë°®ÔΩúTruth Table

| A | B | C_in | S | C_out |
|---|---|------|---|-------|
| 0 | 0 | 0    | 0 | 0     |
| 0 | 0 | 1    | 1 | 0     |
| 0 | 1 | 0    | 1 | 0     |
| 0 | 1 | 1    | 0 | 1     |
| 1 | 0 | 0    | 1 | 0     |
| 1 | 0 | 1    | 0 | 1     |
| 1 | 1 | 0    | 0 | 1     |
| 1 | 1 | 1    | 1 | 1     |

### üìò Âõ≥2.5-2ÔºöÂÖ®Âä†ÁÆóÂô®ÊßãÊàêÂõ≥Ôºà2ÊÆµHAÊßãÊàê„ÄÅMermaidÔºâ

```mermaid
flowchart LR
    subgraph HA1["Half Adder 1"]
        A(A) --> XOR1[XOR]
        B(B) --> XOR1
        XOR1 --> S1(S1)
        A --> AND1[AND]
        B --> AND1
        AND1 --> C1(C1)
    end

    subgraph HA2["Half Adder 2"]
        S1 --> XOR2[XOR]
        Cin(Cin) --> XOR2
        XOR2 --> S(Sum)
        S1 --> AND2[AND]
        Cin --> AND2
        AND2 --> C2(C2)
    end

    C1 --> OR1[OR]
    C2 --> OR1
    OR1 --> Cout(Cout)
```

> Sum is computed through two XOR gates, while carry is derived by combining two intermediate AND outputs via OR.

---

## üîπ Â§ö„Éì„ÉÉ„ÉàÂä†ÁÆóÂô®„Å∏„ÅÆÊã°Âºµ  
### üáØüáµ Ë§áÊï∞„ÅÆÂÖ®Âä†ÁÆóÂô®„ÇíÁõ¥ÂàóÊé•Á∂ö  
### üá∫üá∏ Building multi-bit adders by chaining Full Adders

- **C\_out of previous stage ‚Üí C\_in of next**
- **„É™„ÉÉ„Éó„É´„Ç≠„É£„É™„ÉºÊñπÂºè / Ripple Carry**ÔºöÊßãÈÄ†„ÅØÁ∞°Êòì„Å†„Åå„ÄÅ**ÈÅÖÂª∂„ÅØÊÆµÊï∞„Å´ÊØî‰æã**

### üìò Âõ≥2.5-3Ôºö4„Éì„ÉÉ„Éà„É™„ÉÉ„Éó„É´„Ç≠„É£„É™„ÉºÂä†ÁÆóÂô®ÔºàMermaid„ÉªÁ∞°ÊΩîÁâàÔºâ

```mermaid
flowchart LR
    subgraph FA0["Full Adder 0 (LSB)"]
        A0(A0) --> XOR0[XOR]
        B0(B0) --> XOR0
        Cin(Cin) --> XOR0
        XOR0 --> S0(Sum0)

        A0 --> AND0a[AND]
        B0 --> AND0a
        A0 --> AND0b[AND]
        Cin --> AND0b
        B0 --> AND0c[AND]
        Cin --> AND0c
        AND0a --> OR0a[OR]
        AND0b --> OR0a
        OR0a --> OR0b[OR]
        AND0c --> OR0b
        OR0b --> C1(Cout0)
    end

    subgraph FA1["Full Adder 1"]
        A1(A1) --> XOR1a[XOR]
        B1(B1) --> XOR1a
        C1 --> XOR1a
        XOR1a --> S1(Sum1)

        A1 --> AND1a[AND]
        B1 --> AND1a
        A1 --> AND1b[AND]
        C1 --> AND1b
        B1 --> AND1c[AND]
        C1 --> AND1c
        AND1a --> OR1a[OR]
        AND1b --> OR1a
        OR1a --> OR1b[OR]
        AND1c --> OR1b
        OR1b --> C2(Cout1)
    end

    subgraph FA2["Full Adder 2"]
        A2(A2) --> XOR2a[XOR]
        B2(B2) --> XOR2a
        C2 --> XOR2a
        XOR2a --> S2(Sum2)

        A2 --> AND2a[AND]
        B2 --> AND2a
        A2 --> AND2b[AND]
        C2 --> AND2b
        B2 --> AND2c[AND]
        C2 --> AND2c
        AND2a --> OR2a[OR]
        AND2b --> OR2a
        OR2a --> OR2b[OR]
        AND2c --> OR2b
        OR2b --> C3(Cout2)
    end

    subgraph FA3["Full Adder 3 (MSB)"]
        A3(A3) --> XOR3a[XOR]
        B3(B3) --> XOR3a
        C3 --> XOR3a
        XOR3a --> S3(Sum3)

        A3 --> AND3a[AND]
        B3 --> AND3a
        A3 --> AND3b[AND]
        C3 --> AND3b
        B3 --> AND3c[AND]
        C3 --> AND3c
        AND3a --> OR3a[OR]
        AND3b --> OR3a
        OR3a --> OR3b[OR]
        AND3c --> OR3b
        OR3b --> Cout(Cout3)
    end
```

> „Åï„Çâ„Å´Á∞°ÊΩî„Å´„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅÂêÑ„Çπ„ÉÜ„Éº„Ç∏„Çí `Full Adder` 1„Éñ„É≠„ÉÉ„ÇØÔºàXOR/AND/OR„ÅÆÂÜÖÈÉ®Ë©≥Á¥∞„ÇíÁúÅÁï•Ôºâ„Å´„Åó„Å¶„ÄÅ`Cout` „ÇíÊ¨°ÊÆµ `Cin` „Å∏Êé•Á∂ö„Åô„Çã„Å†„Åë„ÅÆÂõ≥„ÇÇÁî®ÊÑè„Åß„Åç„Åæ„Åô„ÄÇ

---

## ‚úÖ „Åæ„Å®„ÇÅÔΩúSummary

| üáØüáµ Êó•Êú¨Ë™û | üá∫üá∏ English |
|-----------|------------|
| ÂçäÂä†ÁÆóÂô®„ÅØ **1„Éì„ÉÉ„Éà„ÅÆÂä†ÁÆó„ÇíÊúÄÂ∞èÊßãÊàê„ÅßÂÆüÁèæ** | Half Adder performs 1-bit addition with minimal logic |
| ÂÖ®Âä†ÁÆóÂô®„ÅØ **„Ç≠„É£„É™„ÉºÂÖ•ÂäõËæº„Åø„ÅÆÂü∫Êú¨Âä†ÁÆóÂô®** | Full Adder handles carry-in and forms the basis for multi-bit adders |
| Ë§áÊï∞ÊÆµÊé•Á∂ö„Åß **n„Éì„ÉÉ„ÉàÂä†ÁÆóÂô®„Å´Êã°ÂºµÂèØËÉΩ** | Full Adders can be cascaded to build n-bit adders |
| Âä†ÁÆóÂô®„ÅØ **ALU„ÇÑ„Éó„É≠„Çª„ÉÉ„Çµ„ÅÆ‰∏≠Ê†∏Ë¶ÅÁ¥†** | Adders are essential in ALUs and processors |

---

üìé Ê¨°ÁØÄÔºö[`2.6_fsm_intro.md`](./2.6_fsm_intro.md)  
> **Next**: Introduction to Sequential Circuits and FSM (Finite State Machine)

---

[‚Üê Êàª„Çã / Back to Chapter 2: Combinational Logic Top](./README.md)
