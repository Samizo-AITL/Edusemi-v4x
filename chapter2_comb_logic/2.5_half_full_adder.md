---
layout: default
title: 2.5 半加算器と全加算器の構成
---

---

# 2.5 半加算器と全加算器の構成  
**2.5 Structure of Half and Full Adders**

---

## 🎯 本節のねらい｜Goal of This Section

本節では、デジタル回路で最も基本的かつ重要な演算処理である  
**加算器（Adder）** の構成を学びます。  
> This section focuses on the fundamental logic blocks—**Half Adder** and **Full Adder**—used in digital addition.

---

## 🔹 半加算器（Half Adder）  
### 🇯🇵 2入力ビットの加算を行う最小構成回路  
### 🇺🇸 A minimal logic block that adds two single-bit inputs

- **入力 / Inputs**：A, B（1ビット）  
- **出力 / Outputs**：
  - **Sum（S）** = A ⊕ B  
  - **Carry（C）** = A・B

### 📋 真理値表｜Truth Table

| A | B | S = A ⊕ B | C = A・B |
|---|---|-----------|----------|
| 0 | 0 |     0     |    0     |
| 0 | 1 |     1     |    0     |
| 1 | 0 |     1     |    0     |
| 1 | 1 |     0     |    1     |

### 📘 図2.5-1：半加算器の構成図｜Half Adder Circuit

```mermaid
flowchart LR
    A([A]) --> XOR1[XOR]
    B([B]) --> XOR1
    XOR1 --> S([S = A ⊕ B])

    A --> AND1[AND]
    B --> AND1
    AND1 --> C([C = A · B])
```

```
   A ─────────────┐
                 ▼
               ┌────┐
               │XOR │───▶ Sum（S）
               └────┘
                 ▲
   B ─────────────┘

   A ─────┐
          ▼
        ┌────┐
        │AND │───▶ Carry（C）
        └────┘
          ▲
   B ─────┘
```

> XOR generates the sum, AND generates the carry output.

---

## 🔹 全加算器（Full Adder）  
### 🇯🇵 キャリー入力付き1ビット加算器  
### 🇺🇸 A 1-bit adder with carry-in support

- **入力 / Inputs**：A, B, C<sub>in</sub>（キャリー入力）  
- **出力 / Outputs**：
  - **Sum（S）** = A ⊕ B ⊕ C<sub>in</sub>  
  - **Carry（C<sub>out</sub>）** = A・B + B・C<sub>in</sub> + A・C<sub>in</sub>

### 📋 真理値表｜Truth Table

| A | B | C<sub>in</sub> | S | C<sub>out</sub> |
|---|---|----------------|---|-----------------|
| 0 | 0 | 0              | 0 | 0               |
| 0 | 0 | 1              | 1 | 0               |
| 0 | 1 | 0              | 1 | 0               |
| 0 | 1 | 1              | 0 | 1               |
| 1 | 0 | 0              | 1 | 0               |
| 1 | 0 | 1              | 0 | 1               |
| 1 | 1 | 0              | 0 | 1               |
| 1 | 1 | 1              | 1 | 1               |

### 📘 図2.5-2：全加算器構成図（2段HA構成）｜Full Adder Structure

```mermaid
flowchart LR
    subgraph HA1[Half Adder 1]
        A([A]) --> XOR1[XOR]
        B([B]) --> XOR1
        XOR1 --> S1([S1])
        A --> AND1[AND]
        B --> AND1
        AND1 --> C1([C1])
    end

    subgraph HA2[Half Adder 2]
        S1 --> XOR2[XOR]
        Cin([Cin]) --> XOR2
        XOR2 --> S([Sum])
        S1 --> AND2[AND]
        Cin --> AND2
        AND2 --> C2([C2])
    end

    C1 --> OR1[OR]
    C2 --> OR1
    OR1 --> Cout([Cout])
```
    
```
    A ─────┐
           ▼
        ┌───────┐
        │ Half  │
        │ Adder │
        └──┬────┘
           │S1
           ▼
        ┌───────┐
    B ─▶│ Half  │
        │ Adder │
   Cin─▶└──┬────┘
            │S（合計）
            ▼
          [Sum]

           ▲
           │
        ┌──┴──┐
        │ OR  │◀── Carry from 2つの HA
        └──┬──┘
           │
         [Cout（桁上がり）]
```

> Sum is computed through two XOR gates, while carry is derived by combining two intermediate AND outputs via OR.

---

## 🔹 多ビット加算器への拡張  
### 🇯🇵 複数の全加算器を直列接続  
### 🇺🇸 Building multi-bit adders by chaining Full Adders

- **C<sub>out</sub> of previous stage → C<sub>in</sub> of next**
- **リップルキャリー方式 / Ripple Carry**：構造は簡易だが、**遅延は段数に比例**

### 📘 図2.5-3：4ビットリップルキャリー加算器｜4-bit Ripple Carry Adder

```mermaid
flowchart LR
    subgraph FA0[Full Adder 0 (LSB)]
        A0([A0]) --> XOR0[XOR]
        B0([B0]) --> XOR0
        Cin0([Cin]) --> XOR0
        XOR0 --> S0([Sum0])
        A0 --> AND0a[AND]
        B0 --> AND0a
        A0 --> AND0b[AND]
        Cin0 --> AND0b
        B0 --> AND0c[AND]
        Cin0 --> AND0c
        AND0a --> OR0a[OR]
        AND0b --> OR0a
        OR0a --> OR0b[OR]
        AND0c --> OR0b
        OR0b --> C1([Cout0])
    end

    subgraph FA1[Full Adder 1]
        A1([A1]) --> XOR1a[XOR]
        B1([B1]) --> XOR1a
        C1 --> XOR1a
        XOR1a --> S1([Sum1])
        A1 --> AND1a[AND]
        B1 --> AND1a
        A1 --> AND1b[AND]
        C1 --> AND1b
        B1 --> AND1c[AND]
        C1 --> AND1c
        AND1a --> OR1a[OR]
        AND1b --> OR1a
        OR1a --> OR1b[OR]
        AND1c --> OR1b
        OR1b --> C2([Cout1])
    end

    subgraph FA2[Full Adder 2]
        A2([A2]) --> XOR2a[XOR]
        B2([B2]) --> XOR2a
        C2 --> XOR2a
        XOR2a --> S2([Sum2])
        A2 --> AND2a[AND]
        B2 --> AND2a
        A2 --> AND2b[AND]
        C2 --> AND2b
        B2 --> AND2c[AND]
        C2 --> AND2c
        AND2a --> OR2a[OR]
        AND2b --> OR2a
        OR2a --> OR2b[OR]
        AND2c --> OR2b
        OR2b --> C3([Cout2])
    end

    subgraph FA3[Full Adder 3 (MSB)]
        A3([A3]) --> XOR3a[XOR]
        B3([B3]) --> XOR3a
        C3 --> XOR3a
        XOR3a --> S3([Sum3])
        A3 --> AND3a[AND]
        B3 --> AND3a
        A3 --> AND3b[AND]
        C3 --> AND3b
        B3 --> AND3c[AND]
        C3 --> AND3c
        AND3a --> OR3a[OR]
        AND3b --> OR3a
        OR3a --> OR3b[OR]
        AND3c --> OR3b
        OR3b --> Cout([Cout3])
    end
```


```
   A3 B3 Cin────────────┐
                       ▼
                  ┌─────────┐
                  │ Full    │
         Cout3 ◀──│ Adder   │──▶ Sum3
                  └─────────┘
                       ▲
   A2 B2               │
         ──────────────┘
                       ▼
                  ┌─────────┐
                  │ Full    │
         Cout2 ◀──│ Adder   │──▶ Sum2
                  └─────────┘
                       ▲
   A1 B1               │
         ──────────────┘
                       ▼
                  ┌─────────┐
                  │ Full    │
         Cout1 ◀──│ Adder   │──▶ Sum1
                  └─────────┘
                       ▲
   A0 B0               │
         ──────────────┘
                       ▼
                  ┌─────────┐
                  │ Full    │
         Cout0 ◀──│ Adder   │──▶ Sum0
                  └─────────┘

※ Cin（初期キャリー） → 最下位の Full Adder に入力
※ Cout3 → 全体のキャリー出力（桁上がり）
```

---

## ✅ まとめ｜Summary

| 🇯🇵 日本語 | 🇺🇸 English |
|-----------|------------|
| 半加算器は **1ビットの加算を最小構成で実現** | Half Adder performs 1-bit addition with minimal logic |
| 全加算器は **キャリー入力込みの基本加算器** | Full Adder handles carry-in and forms the basis for multi-bit adders |
| 複数段接続で **nビット加算器に拡張可能** | Full Adders can be cascaded to build n-bit adders |
| 加算器は **ALUやプロセッサの中核要素** | Adders are essential in ALUs and processors |

---

📎 次節：[`2.6_fsm_intro.md`](./2.6_fsm_intro.md)  
> **Next**: Introduction to Sequential Circuits and FSM (Finite State Machine)

---

[← 戻る / Back to Chapter 2: Combinational Logic Top](./README.md)
