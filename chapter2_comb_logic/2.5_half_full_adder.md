---
layout: default
title: 2.5 åŠåŠ ç®—å™¨ã¨å…¨åŠ ç®—å™¨ã®æ§‹æˆ
---

---

# 2.5 åŠåŠ ç®—å™¨ã¨å…¨åŠ ç®—å™¨ã®æ§‹æˆ  
**2.5 Structure of Half and Full Adders**

---

## ğŸ¯ æœ¬ç¯€ã®ã­ã‚‰ã„ï½œGoal of This Section

æœ¬ç¯€ã§ã¯ã€ãƒ‡ã‚¸ã‚¿ãƒ«å›è·¯ã§æœ€ã‚‚åŸºæœ¬çš„ã‹ã¤é‡è¦ãªæ¼”ç®—å‡¦ç†ã§ã‚ã‚‹  
**åŠ ç®—å™¨ï¼ˆAdderï¼‰** ã®æ§‹æˆã‚’å­¦ã³ã¾ã™ã€‚  
> This section focuses on the fundamental logic blocksâ€”**Half Adder** and **Full Adder**â€”used in digital addition.

---

## ğŸ”¹ åŠåŠ ç®—å™¨ï¼ˆHalf Adderï¼‰  
### ğŸ‡¯ğŸ‡µ 2å…¥åŠ›ãƒ“ãƒƒãƒˆã®åŠ ç®—ã‚’è¡Œã†æœ€å°æ§‹æˆå›è·¯  
### ğŸ‡ºğŸ‡¸ A minimal logic block that adds two single-bit inputs

- **å…¥åŠ› / Inputs**ï¼šA, Bï¼ˆ1ãƒ“ãƒƒãƒˆï¼‰  
- **å‡ºåŠ› / Outputs**ï¼š
  - **Sumï¼ˆSï¼‰** = A âŠ• B  
  - **Carryï¼ˆCï¼‰** = Aãƒ»B

### ğŸ“‹ çœŸç†å€¤è¡¨ï½œTruth Table

| A | B | S = A âŠ• B | C = Aãƒ»B |
|---|---|-----------|----------|
| 0 | 0 |     0     |    0     |
| 0 | 1 |     1     |    0     |
| 1 | 0 |     1     |    0     |
| 1 | 1 |     0     |    1     |

### ğŸ“˜ å›³2.5-1ï¼šåŠåŠ ç®—å™¨ã®æ§‹æˆå›³ï½œHalf Adder Circuit

```mermaid
flowchart LR
    A([A]) --> XOR1[XOR]
    B([B]) --> XOR1
    XOR1 --> S([S = A âŠ• B])

    A --> AND1[AND]
    B --> AND1
    AND1 --> C([C = A Â· B])
```

```
   A â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â–¼
               â”Œâ”€â”€â”€â”€â”
               â”‚XOR â”‚â”€â”€â”€â–¶ Sumï¼ˆSï¼‰
               â””â”€â”€â”€â”€â”˜
                 â–²
   B â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   A â”€â”€â”€â”€â”€â”
          â–¼
        â”Œâ”€â”€â”€â”€â”
        â”‚AND â”‚â”€â”€â”€â–¶ Carryï¼ˆCï¼‰
        â””â”€â”€â”€â”€â”˜
          â–²
   B â”€â”€â”€â”€â”€â”˜
```

> XOR generates the sum, AND generates the carry output.

---

## ğŸ”¹ å…¨åŠ ç®—å™¨ï¼ˆFull Adderï¼‰  
### ğŸ‡¯ğŸ‡µ ã‚­ãƒ£ãƒªãƒ¼å…¥åŠ›ä»˜ã1ãƒ“ãƒƒãƒˆåŠ ç®—å™¨  
### ğŸ‡ºğŸ‡¸ A 1-bit adder with carry-in support

- **å…¥åŠ› / Inputs**ï¼šA, B, C<sub>in</sub>ï¼ˆã‚­ãƒ£ãƒªãƒ¼å…¥åŠ›ï¼‰  
- **å‡ºåŠ› / Outputs**ï¼š
  - **Sumï¼ˆSï¼‰** = A âŠ• B âŠ• C<sub>in</sub>  
  - **Carryï¼ˆC<sub>out</sub>ï¼‰** = Aãƒ»B + Bãƒ»C<sub>in</sub> + Aãƒ»C<sub>in</sub>

### ğŸ“‹ çœŸç†å€¤è¡¨ï½œTruth Table

| A | B | C<sub>in</sub> | S | C<sub>out</sub> |
|---|---|----------------|---|-----------------|
| 0 | 0 | 0              | 0 | 0               |
| 0 | 0 | 1              | 1 | 0               |
| 0 | 1 | 0              | 1 | 0               |
| 0 | 1 | 1              | 0 | 1               |
| 1 | 0 | 0              | 1 | 0               |
| 1 | 0 | 1              | 0 | 1               |
| 1 | 1 | 0              | 0 | 1               |
| 1 | 1 | 1              | 1 | 1               |

### ğŸ“˜ å›³2.5-2ï¼šå…¨åŠ ç®—å™¨æ§‹æˆå›³ï¼ˆ2æ®µHAæ§‹æˆï¼‰ï½œFull Adder Structure

```mermaid
flowchart LR
    subgraph HA1[Half Adder 1]
        A([A]) --> XOR1[XOR]
        B([B]) --> XOR1
        XOR1 --> S1([S1])
        A --> AND1[AND]
        B --> AND1
        AND1 --> C1([C1])
    end

    subgraph HA2[Half Adder 2]
        S1 --> XOR2[XOR]
        Cin([Cin]) --> XOR2
        XOR2 --> S([Sum])
        S1 --> AND2[AND]
        Cin --> AND2
        AND2 --> C2([C2])
    end

    C1 --> OR1[OR]
    C2 --> OR1
    OR1 --> Cout([Cout])
```
    
```
    A â”€â”€â”€â”€â”€â”
           â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Half  â”‚
        â”‚ Adder â”‚
        â””â”€â”€â”¬â”€â”€â”€â”€â”˜
           â”‚S1
           â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”
    B â”€â–¶â”‚ Half  â”‚
        â”‚ Adder â”‚
   Cinâ”€â–¶â””â”€â”€â”¬â”€â”€â”€â”€â”˜
            â”‚Sï¼ˆåˆè¨ˆï¼‰
            â–¼
          [Sum]

           â–²
           â”‚
        â”Œâ”€â”€â”´â”€â”€â”
        â”‚ OR  â”‚â—€â”€â”€ Carry from 2ã¤ã® HA
        â””â”€â”€â”¬â”€â”€â”˜
           â”‚
         [Coutï¼ˆæ¡ä¸ŠãŒã‚Šï¼‰]
```

> Sum is computed through two XOR gates, while carry is derived by combining two intermediate AND outputs via OR.

---

## ğŸ”¹ å¤šãƒ“ãƒƒãƒˆåŠ ç®—å™¨ã¸ã®æ‹¡å¼µ  
### ğŸ‡¯ğŸ‡µ è¤‡æ•°ã®å…¨åŠ ç®—å™¨ã‚’ç›´åˆ—æ¥ç¶š  
### ğŸ‡ºğŸ‡¸ Building multi-bit adders by chaining Full Adders

- **C<sub>out</sub> of previous stage â†’ C<sub>in</sub> of next**
- **ãƒªãƒƒãƒ—ãƒ«ã‚­ãƒ£ãƒªãƒ¼æ–¹å¼ / Ripple Carry**ï¼šæ§‹é€ ã¯ç°¡æ˜“ã ãŒã€**é…å»¶ã¯æ®µæ•°ã«æ¯”ä¾‹**

### ğŸ“˜ å›³2.5-3ï¼š4ãƒ“ãƒƒãƒˆãƒªãƒƒãƒ—ãƒ«ã‚­ãƒ£ãƒªãƒ¼åŠ ç®—å™¨ï½œ4-bit Ripple Carry Adder

```
   A3 B3 Cinâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚ Full    â”‚
         Cout3 â—€â”€â”€â”‚ Adder   â”‚â”€â”€â–¶ Sum3
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â–²
   A2 B2               â”‚
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚ Full    â”‚
         Cout2 â—€â”€â”€â”‚ Adder   â”‚â”€â”€â–¶ Sum2
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â–²
   A1 B1               â”‚
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚ Full    â”‚
         Cout1 â—€â”€â”€â”‚ Adder   â”‚â”€â”€â–¶ Sum1
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â–²
   A0 B0               â”‚
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚ Full    â”‚
         Cout0 â—€â”€â”€â”‚ Adder   â”‚â”€â”€â–¶ Sum0
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â€» Cinï¼ˆåˆæœŸã‚­ãƒ£ãƒªãƒ¼ï¼‰ â†’ æœ€ä¸‹ä½ã® Full Adder ã«å…¥åŠ›
â€» Cout3 â†’ å…¨ä½“ã®ã‚­ãƒ£ãƒªãƒ¼å‡ºåŠ›ï¼ˆæ¡ä¸ŠãŒã‚Šï¼‰
```

---

## âœ… ã¾ã¨ã‚ï½œSummary

| ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª | ğŸ‡ºğŸ‡¸ English |
|-----------|------------|
| åŠåŠ ç®—å™¨ã¯ **1ãƒ“ãƒƒãƒˆã®åŠ ç®—ã‚’æœ€å°æ§‹æˆã§å®Ÿç¾** | Half Adder performs 1-bit addition with minimal logic |
| å…¨åŠ ç®—å™¨ã¯ **ã‚­ãƒ£ãƒªãƒ¼å…¥åŠ›è¾¼ã¿ã®åŸºæœ¬åŠ ç®—å™¨** | Full Adder handles carry-in and forms the basis for multi-bit adders |
| è¤‡æ•°æ®µæ¥ç¶šã§ **nãƒ“ãƒƒãƒˆåŠ ç®—å™¨ã«æ‹¡å¼µå¯èƒ½** | Full Adders can be cascaded to build n-bit adders |
| åŠ ç®—å™¨ã¯ **ALUã‚„ãƒ—ãƒ­ã‚»ãƒƒã‚µã®ä¸­æ ¸è¦ç´ ** | Adders are essential in ALUs and processors |

---

ğŸ“ æ¬¡ç¯€ï¼š[`2.6_fsm_intro.md`](./2.6_fsm_intro.md)  
> **Next**: Introduction to Sequential Circuits and FSM (Finite State Machine)

---

[â† æˆ»ã‚‹ / Back to Chapter 2: Combinational Logic Top](./README.md)
